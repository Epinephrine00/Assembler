<h1>Assembler!</h1>

------------------------------

여러 언어로 16비트 어셈블러를 구현해보는 프로젝트입니다. 

실행 테스트를 위한 16비트 CPU 및 64KB 메모리 에뮬레이터를 포함합니다.

한국교통대학교 컴퓨터공학과 2024년 <컴퓨터 구조> 강의의 2주차 과제에 대한 제출물을 개발하기 위해 시작되었습니다. 

모든 코드는 한국교통대학교 컴퓨터공학전공 22학번 <a  href="https://github.com/Epinephrine00">이두현</a> 및 19학번 <a href="https://github.com/PuSuu">채준수</a> 학생이 강의자료 및 강의 내용 외 아무런 외부 도움 없이 독자적으로 작성하였음을 밝힙니다. 

contact : 

- 이두현 - epinephrine00@a.ut.ac.kr / epi00nephrine@gmail.com
- 채준수 - kimoh0605@gmail.com

혹여나 과제 채점 과정에서 코드 작성자의 개인정보 인증이 필요하다면 위 연락처로 연락 부탁드리겠습니다. 

<br/>

--------------------------------

### 어셈블러 소스코드 파일 :

```
PyAsm/pade.py
CAsm/cas_cade.c
JAsm/jasm/Jade.java
```
*Java의 경우 시스템상 설치된 JDK를 Gradle이 제대로 잡지 못하는 등 말썽을 부리느라 Gradle 또는 Maven Project가 아닌 *.class, *.java 파일로 작성했습니다.... 

### 어셈블러 사용 방법

```
python PyAsm/pade.py "입력파일 이름.asm" "출력파일 이름(선택).obje"
CAsm/cas_cade "입력파일 이름.asm" "출력파일 이름(선택).obje"
cd JAsm & java jasm/Jade "입력파일 이름.asm" "출력파일 이름(선택).obje"

 - 출력파일 이름을 입력하지 않으면 "입력파일 이름.obje"로 자동으로 저장됩니다. 
```

위 명령어를 통해 어셈블리 코드를 obje파일로 번역합니다!

```
python PyAsm/loader.py "입력파일 이름.obje"
```
위 명령어를 통해 번역된 결과를 실행해볼 수 있습니다!

16비트 CPU와 64kb 메모리를 에뮬레이팅하여 obje파일로 번역된 코드를 메모리에 적재한 뒤 실행한 결과 및 메모리의 내용 등을 표시해줍니다. 

--------------------------------


### OBJE 파일 설명


```add2nums.asm
    ORG 0
    INP
    STA A
    INP
    ADD A
    OUT
    HLT
A,  HEX 0
    END
```

```add2nums.obje
0000F800000130060002F800000310060004F4000005700100060000
```

위 두 코드는 각각 두 정수를 입력받아 둘을 더한 값에 해당하는 ASCII 문자로 출력하는 16비트 어셈블리 코드와, 본 프로젝트에서 작성한 어셈블러를 이용해 해당 어셈블리 코드를 번역한 결과입니다. 


obje 파일을 8글자씩 나누어 줄을 바꾸고, 4자리씩 끊어서 쓰면 다음과 같아집니다. 

```add2nums.obje
0000 F800
0001 3006
0002 F800
0003 1006
0004 F400
0005 7001
0006 0000
```

아마 눈치 채신 분들도 있겠지만, 왼쪽에 해당하는 숫자들은 0부터 순차적으로 높아집니다. 

반대로, 오른 쪽에 해당하는 숫자들은 규칙성이 눈에 띄지 않습니다. 

obje파일은 기계어 명령어(또는 레이블의 값)를 LC값, 즉 해당 값이 메모리상에 저장될 순번과 함께 저장됩니다. 

따라서, 왼쪽의 값은 LC값, 오른쪽의 값이 기계어 명령어가 됩니다. 

즉, *.obje 파일을 loader.py를 통해 실행하게되면, loader.py는 메모리의 코드 오프셋 주소로부터 LC 순번에 따라 값을 저장한 뒤 프로그램을 실행합니다. 

--------------------------------

### TODO

 - <i> ~~Python으로 16비트 CPU 에뮬레이터 구현~~ </i> (완?)
    - 낭만 넘치게 사칙연산 기호에서 손을 떼었습니다. =, |, &, not 연산자만을 이용했습니다!
    - 완성은 하였으나, 예외 처리 및 입출력 명령어 등 귀찮은 부분은 건들이지 않았습니다. 어셈블러가 어떻게든 잘 핸들링해줄거라 믿습니다. 
    - 추후 자잘한 기능 개선이 필요할수도 있습니다. 
 - <i> ~~Python으로 64KB 메모리 에뮬레이터 구현~~ </i> (완)
    - 이건 사칙연산 썼습니다,,,, 리스트로 구현했는데 인덱싱때문에 그냥 반복문 돌리고 인덱스 + - 썼습니다... 
 - <i> ~~실행기 구현~~ </i> (완)
    - loader.py입니다. obje파일을 읽어 메모리에 코드를 올리고, CPU를 호출해 메모리의 코드를 실행합니다. 
 - <i> ~~C로 어셈블러 구현~~ </i> (완)
 - <i> ~~Python으로 어셈블러 구현~~ </i> (완)
 - Java로 어셈블러 구현 (진행중)
 - Kotlin으로 어셈블러 구현 ~~(자바로 만들고 번역기 돌리면 그만 아닌가..?)~~
 - Assembly로 어셈블러 구현 (?)

--------------------------------

### Special Thanks

좋은 강의를 해주시고 즐거운 과제를 내주신 구*근 교수님께 가장 큰 감사를 드립니다. 

 - ...비꼬는게 아닙니다! __진심으로 즐겁게__ 생각하고있습니다.
 - 즐겁지 않았다면 굳이 이걸 여러 언어로 만드는 시간 낭비는 하지 않았을것입니다. 진심으로 즐기고있습니다 감사합니다 :)

<br/>

작업 진행중 귀를 심심하지 않게 해준 다나카 케이이치로, 다나카 미나미, 런즈베리 아서 등 여러 음악인 및 성우분들께 감사드립니다. 

----------------------------------

All Wrongs Reserved (ɔ) Epinephrine00 in Embeded System Design Lab., Department of Computer Engineering, School of Computer, Korea National University of Transportation

<br/>

Genesis 1:3  |  _Dixitque Deus: "Fiat Lux", Et Facta Est Lux._  
창세기 1:3  |  _하나님이 이르시되 빛이 있으라 하시니 빛이 있었고._